\documentclass{article}

\begin{document}

\section {Intro}
Normally unification is presented in catergory-theoretic terms as a coequalizer:

we have an indexed set of equations $s_i = t_i$ where the $\{s_i, t_i\}$ are terms.
Then we ask the algorithm for a most generic unifier $q$.

TODO: describe how the unification works.

\section {Observation 1}
The first observation is that why not only deal with substitutions only? I.e. invent a finite set of variable names $vl_i$ and $vr_i$ and let those point to $s_i$ resp. $t_i$. Then we have a bona fide substitution $V \to T_{\Omega}W$, where $W$ is the variable set of our terms $\{s_i, t_i\}$.

\section {Observation 2}
The second observation is that having substitutions with just variables as the substituend kills the symmetry in the unification algorithm. (HOW SO?) So we'll forbid $v \to w$ substitutions altogether. Now when we encounter a unification necessity $v \equiv w$ what should we do?
My suggestion is to create an equivalence class of variable names that contains both $v$ and $w$. We'll revisit this issue later but for now it is enough to hint at path-connectedness (i.e. \emph{groupoids}).

Then the domain of our Kleisli-arrows must be equivalence classes of variable names. Since a single variable name in $T_{\Omega}W$ uniquely determines the equivalence class of variable names, why not also pass to quotients in $T_{\Omega}W$?
We'll do so now. What we get is monads over equivalence classes (quotiened sets). This also means that the number of bindings in unifiers will potentially decrease, because
\begin{itemize}
\item[a)] we do not have variable-to-variable substitutions any more,
\item[b)] we'll have only one instead of $\{a \to x, b \to y\}$ bindings when $a$ and $b$ happen to land in the same equivalence class.
\end{itemize}
But this brings us to the principal problem with this approach. When we augment an equivalence class for whatever reason, we have to hunt down all bindings that are affected and coalesce them. Which in turn may expose more obligations to merge classes until a fixpoint is reached. When we had a finite number of variable names to start with, this process will terminate.
\par Our algorithm must keep a worklist of outstanding unification necessities (i.e. unmerged terms) and the current up-to-date substitution with consolidated equivalence classes.
When the former list becomes empty, we have the desired mgu in our hands.
If we can establish a correct-by construction data type for substitutions that precludes the possibility of overlapping equivalence classes in the key- as well as the term set of the substitution, then we get an almost machine-checked algorithm.

\section {Groupoids}
Let's come back to the idea of equivalence classes. We noted that they merge when we encounter two variable names (or more precisely their classes) that must be unified. But how can we make the notion of the classes precise? I propose to build paths between variable names, thus obtain path-connected components in the set of variable names. The elements of the loop space then become the connected components and classes. TODO: check that this is indeed a groupoid. $T_{\Omega}$ is then a functor between groupoids.

\section {Bibliography}
\begin{itemize}
\item Goguen 89
\item Burstall-Rydeheard
\end{itemize}
\end{document}
