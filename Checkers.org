* Introduction

We are inspired by http://bentnib.org 's idea of equational theories for type checking. There he derives type checker objects.
At the same time adding the idea of located trees and references (into the same subtree or even outside, c.f. =letrec=).

* Stuff and checkers


Profunctor? <image>

<image> (a hole in a context)
<image> l, l.0, l.1 are compositional type checkers (Atkey)

<image> =Z= is a reference to a constructor defined elsewhere under int.0 Similarly =succ= under int.0

int.0 translates into a typechecker <image>

int-2 translates into a type checker <image>

** Stuff

So any thing arranged in a hierarchical scheme with implicitly assigned locations is the stuff

** Checkers

Stuff has types (at level 1) and that has types again (at level 2) which correspond to the kinds. These also want to be checked. So checkers will live at any level. Even checkers at level 0 make sense for some stuff like (saturated) constructors.

<image> will pass.

We will need this for refinemennt etc. or pattern matching.

So we have /things/ and /checkers/ and we can /pass/ the former to the latter (at the corresponding levels).

> Analogy to QFT (quantum field theory) where particles are excitations of fields.

* Universality

There is a /joker/ thing at every level, which is accepted by every checker. Passing a /joker context/ one gets the real thing that can fill teh context.

<image> (*): wildcard.

We get the precise filler.

This embeds things into the checkers.

_Open question_: Are there joker fillers? What happens when these get passed? What is returned?

* Combining checkers

A checker corresponding to @ (the application AST node) combines the checkers of its legs below to a new compound checker.

<image>

* Locations

Things live in the /source code space/ (AST) and each node has an implicitly assigned location.

We should have the notion of /argument location/ (in abstraction) proxying the /definition location/ of things, which is opaque from the abstraction's body's perspective.

** Inlining

The process of inlining (i.e. replacing a left leg below and @ node with the reference pointee) relates these locations, eliminating a layer of opacity.

* The levelled groupoid

Starting with level 0 (the values) we have a groupoid.

** Transformers, function-typed things have the same drain and source locations

type a       OOOOO    loc f (drain oriented)
with loc at level 1
  <image>
type b              OOOOOOOOOO    loc f (source oriented)
with loc at level 1

/Oriented locations/ are the objects of the groupoid.

@-AST-nodes connect argument source locations with transformer drain locations. This is an identification (path) in the HIT sense on level 0.

On level 1, @-nodes effectively identify the (locations of) types. Which gives rise to the classical /type checking constraints/.

* Lambdas and quantifiers

|level | star | | | | ...
|.| *|
|.| *|
|3| *|
|2| *| ∏||
|1|  | π | Λ|
|0|  |   | λ|
|level | 0 | 1|2 |3 | distance

We have a grid of abstractors, where λ is at (2,0) and π is at (1,1).

Images to fill in here...

** Quantifiers

<image> at some level

Of course we want dependencies (as in π) aequi-levelled, so we use refinement types for λ, Λ. There is no problem,

<image>

where a, a', a'' etc. are isomorphic but on higher levels.

* Quantifiers and the groupoid

The left leg of a λ-node is a portal for other (sometimes unknown-location) things.

AST: @ and λ-nodes connect sources with drains.

Checkers: ensure that values travel type-safe.
