#summary Syntax for name juxtaposition being more general than function application.
#labels crazy

= Introduction =

Currently when we juxtapose expressions in Î©mega we get function application. Look at this: expression `map ord "Hello"`; once written you'll get value of `[Int]` and you cannot control the process. This is pretty much unavoidable, just like the type constraints that are imposed on `map` and `ord`.

We propose a new syntactical element that liberates juxtaposition from these fixed rules and allows us to assign semantics to it in a flexible fashion by the `do data` syntax.

== Why at all? ==

The most important reason is that we want to use the syntax for constructing other types of data than executable code. For example we may want to write down hardware descriptions just like we do haskell. Of course we cannot (and usually don't want to) execute it, but capture it for later transformations.
The idea to this proposal came after digesting Wadler et al.'s paper about the _arrow calculus_. There he introduces _arrow applications_, _lambdas_ and _let_s. For each arrow, presumably.

= Details =

We'll define the syntactical sugar for our proposed language feature and define its expansion.

== The New Syntax ==

Here is an example:

{{{
do data (,) { "Hello" (ord map) }
  where do a b = b, a
}}}

This would expand to `((map, ord), "Hello") :: (((a->b)->[a]->[b],Char->Int), [Char])`.
The `where data` clause forces the AST builder to rearrange juxtapositions to their reversals inserting a comma in between, and the `do data (,)` determines that the the type rules are according to the _pair_ type constructor.

== Lambdas? ==

This clause could change the lambda syntax' behaviour: `where do \x -> "x"` as an example of the "C" stringize operator.

= References =

  * http://web.cecs.pdx.edu/~sheard/papers/HFL07Sheard.pdf
  * http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf