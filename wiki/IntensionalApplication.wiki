#summary Syntax for name juxtaposition being more general than function application.
#labels crazy

= Introduction =

Currently when we juxtapose expressions in 立mega we get function application. Look at this: expression `map ord "Hello"`; once written you'll get value of `[Int]` and you cannot control the process. This is pretty much unavoidable, just like the type constraints that are imposed on `map` and `ord`.

We propose a new syntactical element that liberates juxtaposition from these fixed rules and allows us to assign semantics to it in a flexible fashion by the `do data` syntax.

== Why at all? ==

The most important reason is that we want to use the familiar syntax for constructing other types of data than executable code. For example we may want to write down hardware descriptions just like we do in Haskell. Of course we cannot (and usually don't want to) execute it, but capture it for later transformations.

The idea to this proposal came after digesting Wadler et al.'s paper about the _arrow calculus_. There he introduces _arrow applications_, _lambdas_ and _lets_. For each arrow, presumably.

Accidentally, in Haskell and 立mega already use a similar mechanisms
  * namely on the right hand side of the `::` notation, where juxtaposition means application of kind arrows for parameterized data types (or type families/functions)
  * on the left hand side of equations, where juxtaposition means pattern construction and analysis
  * in 立mega's `{typefun arg1 arg2}` brackets (or Haskell's _type family_ calls) it is type function application
  * following `type` or `data` keyword in definitions, the type parameters.

= Details =

We'll define the syntactical sugar for our proposed language feature and define its expansion. This is basically a restricted macro expander.

== The New Syntax ==

Here is an example:

{{{
do data (,) { "Hello" (ord map) }
  where do a b = b, a
}}}

This would expand to `((map, ord), "Hello") :: (((a->b)->[a]->[b],Char->Int), [Char])`.
The `where do` clause forces the AST builder to rearrange juxtapositions to their reversals inserting a comma in between, and the `do data (,)` determines that the the type rules are according to the _pair_ type constructor.

The equation after the `do` keyword must be a syntactically valid equation, with function-like pattern on the left side.

== Another Variant ==

Looking at the problem from another angle, 立mega already has a way of building `Code`, namely with these brackets: `[| ... |]`. We can beat kill two flies with a fell swoop by introducing a new kind of syntax derivation:

{{{
data Codigo :: * where
  Fun :: String -> Codgigo
  Apply :: Codgigo -> Int -> Codgigo
 deriving syntax(c) Code(Fun, Apply)
}}}

This allows us to write `[|"plus" 45 54|]c` and expands to `Apply (Apply (Fun "plus") 45) 54`.

The second fly we killed is _escaping_: using `$(...)` we can get out of the syntactic expansion's world and fall back to the semantics of the outer context.

== Lambdas? ==

This clause could change the lambda syntax' behaviour: `where do \x -> "x"` as an example of the "C" stringize operator.

In _code brackets_ these are  already present, we only need a new constructor, either
  # `Abs :: Label var -> Codgigo -> Codgigo`, or
  # `Abs :: String -> Codgigo -> Codgigo`.

== `let` definitions? ==

`where do let a = expr`

In _code brackets_ these are  already present, we only need a new constructor, either
  # `Let :: Record (Row Tag *) -> Codigo -> Codgigo`, or
  # `Let :: [(String, a)] -> Codigo -> Codgigo`.

The `where` clauses would map to `Let`.

= References =

  * http://web.cecs.pdx.edu/~sheard/papers/HFL07Sheard.pdf
  * http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf